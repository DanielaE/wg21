---
title: Integration of chrono with text formatting
document: P1361R0
date: 2018-10-16
audience: Library Evolution Working Group, Library Working Group
author:
  - name: Victor Zverovich
    email: <victor.zverovich@gmail.com>
favicon: data:image/png;base64,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
---

> "If fmt (P0645) moves forward within the LEWG, this section (Formatting) can
> easily be reworked to plug into that facility without loss of functionality.
> This will avoid two unrelated format facilities in the standard."
>
> -- [@P0355]

# Motivation

[@P0355] that includes a `strftime`-like formatting facility for chrono types
was adopted into the draft standard for C++20 in Jacksonville. Meanwhile
[@P0645] that provides a more general formatting facility was accepted by the
Library Evolution working group in San Diego and forwarded to the Library
working group for a wording review also targeting C++20. In this paper we
propose revising the output APIs added by [@P0355] based on [@P0645].

Integrating the two proposals provides the following advantages:

1. Easier formatting of multiple objects and positional arguments support:

   **Before**
   ```cpp
   void print_birthday(std::string_view name,
                       const std::chrono::year_month_day& birthday) {
     std::cout << name << "'s birthday is "
               << std::chrono::format("%Y-%m-%d", birthday) << ".\n";
   }
   ```

   **After**
   ```cpp
   void print_birthday(std::string_view name,
                       const std::chrono::year_month_day& birthday) {
     std::cout << std::format("{0}'s birthday is {1:%Y-%m-%d}.\n", name, birthday);
   }
   ```

2. Output iterator support and the ability to easily avoid dynamic memory
   allocations:

   **Before**
   ```cpp
   std::string str = std::chrono::format("%Y-%m-%d", date);
   ```

   **After**
   ```cpp
   std::array<char, 100> buf;
   std::format_to_n(buf.data(), buf.size(), "{:%Y-%m-%d}", date);
   ```

3. Prevent confusing overload resolution:

   **Before**
   ```cpp
   std::chrono::year_month_day date;
   format("...", date);                   // resolves to std::chrono::format
   format(std::string_view("..."), date); // resolves to std::format
   ```

   **After**
   ```cpp
   std::chrono::year_month_day date;
   format("...", date);                   // resolves to std::format
   format(std::string_view("..."), date); // resolves to std::format
   ```

4. Allow fill, width, and alignment in a format string using the same syntax as
   for other types:

   **Before**
   ```cpp
   std::cout << std::setw(20) << std::right
             << std::chrono::format("%Y-%m-%d", birthday) << "\n";
   ```

   **After**
   ```cpp
   std::cout << std::format("{0:>20%Y-%m-%d}\n", birthday);
   ```

# Locale

One feature that [@P0355] has and [@P0645] doesn't is the ability to pass a
locale to a formatting fuction. We propose extending the format API of P0645 to
allow the same.


**Before**
```cpp
auto zt = std::chrono::zoned_time(...);
std::cout << "Localized time is "
          << std::chrono::format(std::locale{"fi_FI"}, "%c", zt) << "\n";
```

**After**
```cpp
auto zt = std::chrono::zoned_time(...);
std::cout << std::format(std::locale{"fi_FI"}, "Localized time is {:%c}\n", zt);
```

# Open Questions

HH There's also a std::chrono::parse which this doesn't have. For symmetry
purposes I think we need to alias this to std::chrono as well, but I have not
tried that. Do we care about the lack of symmetry?

# Proposed Wording

This wording is based on the working draft [@N4727] unless stated otherwise.

Modify section 25.2 Header `<chrono>` synopsis
[[time.syn]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.2):

```diff
  // 25.5.10, duration I/O
  template<class charT, class traits, class Rep, class Period>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 const duration<Rep, Period>& d);
- template<class charT, class traits, class Rep, class Period>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const duration<Rep, Period>& d);
+ template<class Rep, class Period, class charT>
+   struct formatter<duration<Rep, Period>, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const sys_days& dp);

- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const sys_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<sys_time<Duration>, charT>;

...

  template<class charT, class traits, class Duration>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const utc_time<Duration>& t);
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const utc_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<utc_time<Duration>, charT>;

...

  template<class charT, class traits, class Duration>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const tai_time<Duration>& t);
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const tai_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<tai_time<Duration>, charT>;

...

  template<class charT, class traits, class Duration>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const gps_time<Duration>& t);
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const gps_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<gps_time<Duration>, charT>;

...

template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const file_time<Duration>& tp);
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const file_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<file_time<Duration>, charT>;

...

  template<class charT, class traits, class Duration>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const local_time<Duration>& tp);
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const local_time<Duration>& tp,
-               const string* abbrev = nullptr, const seconds* offset_sec = nullptr);
+ template<class Duration, class charT>
+   struct formatter<local_time<Duration>, charT>;
+
+ template<class Duration> struct local_time_format;
+ template<class Duration, class charT>
+   struct formatter<local_time_format<Duration>, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const day& d);
- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const day& d);
+ template<class charT>
+   struct formatter<day, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const month& m);
- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month& m);
+ template<class charT>
+   struct formatter<month, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year& y);

- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year& y);
+ template<class charT>
+   struct formatter<year, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const weekday& wd);

- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const weekday& wd);
+ template<class charT>
+   struct formatter<weekday, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const weekday_indexed& wdi);
+ template<class charT>
+   struct formatter<weekday_indexed, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const weekday_last& wdl);
+ template<class charT>
+   struct formatter<weekday_last, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const month_day& md);
- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month_day& md);
+ template<class charT>
+   struct formatter<month_day, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
       operator<<(basic_ostream<charT, traits>& os, const month_day_last& mdl);
+ template<class charT>
+   struct formatter<month_day_last, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const month_weekday& mwd);
+ template<class charT>
+   struct formatter<month_weekday, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const month_weekday_last& mwdl);
+ template<class charT>
+   struct formatter<month_weekday_last, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year_month& ym);

- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year_month& ym);
+ template<class charT>
+   struct formatter<year_month, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year_month_day& ymd);

- template<class charT, class traits>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const year_month_day& ymd);
+ template<class charT>
+   struct formatter<year_month_day, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year_month_day_last& ymdl);
+ template<class charT>
+   struct formatter<year_month_day_last, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year_month_weekday& ymwdi);
+ template<class charT>
+   struct formatter<year_month_weekday, charT>;

...

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const year_month_weekday_last& ymwdl);
+ template<class charT>
+   struct formatter<year_month_weekday_last, charT>;

...

  template<class charT, class traits, class Rep, class Period>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 const time_of_day<duration<Rep, Period>>& t);
+ template<class Rep, class Period, class charT>
+   struct formatter<time_of_day<duration<Rep, Period>>, charT>;

...

  // 25.10.4, information classes
  struct sys_info;
  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const sys_info& si);
+ templateclass charT>
+   struct formatter<sys_info, charT>;

  struct local_info;
  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const local_info& li);
+ template<class charT>
+   struct formatter<local_info, charT>;

...

  template<class charT, class traits, class Duration, class TimeZonePtr>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 const zoned_time<Duration, TimeZonePtr>& t);

- template<class charT, class traits, class Duration, class TimeZonePtr>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const zoned_time<Duration, TimeZonePtr>& tp);
+ template<class Duration, class TimeZonePtr, class charT>
+   struct formatter<zoned_time<Duration, TimeZonePtr>, charT>;

...

- // 25.11, formatting
- template<class charT, class Streamable>
-   basic_string<charT>
-     format(const charT* fmt, const Streamable& s);
- template<class charT, class Streamable>
-   basic_string<charT>
-     format(const locale& loc, const charT* fmt, const Streamable& s);
- template<class charT, class traits, class Alloc, class Streamable>
-   basic_string<charT, traits, Alloc>
-     format(const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);
- template<class charT, class traits, class Alloc, class Streamable>
-   basic_string<charT, traits, Alloc>
-     format(const locale& loc, const basic_string<charT, traits, Alloc>& fmt,
-            const Streamable& s);
```

Modify section 25.5.10 I/O [[time.duration.io]](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#subsection.25.5.10):

```diff
- template<class charT, class traits, class Rep, class Period>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
-               const duration<Rep, Period>& d);
+ template<class Rep, class Period, class charT>
+   struct formatter<duration<Rep, Period>, charT>;
```

> ::: rm
> \pnum{6} *Effects:* Streams `d` into `os` using the format specified by the
> NTCTS `fmt`. `fmt` encoding follows the rules specified in 25.11.
>
> \pnum{7} *Returns:* `os`.
> :::

> ::: add
> The specialization is enabled and the format string encoding follows the rules
> specified in
> [25.11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.11).
> :::

Modify section 25.7.1.3 Non-member functions [[time.clock.system.nonmembers]](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#subsubsection.25.7.1.3):

```diff
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const sys_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<sys_time<Duration>, charT>;
```

> ::: rm
> \pnum{7} *Effects:* Streams `tp` into `os` using the format specified by the
> NTCTS `fmt`. `fmt` encoding follows the rules specified in 25.11. If `%Z`
> is used, it will be replaced with `"UTC"` widened to `charT`. If `%z` is used
> (or a modified variant of `%z`), an offset of `0min` will be formatted.
>
> \pnum{8} *Returns:* `os`.
> :::

> ::: add
> The specialization is enabled and the format string encoding follows the rules
> specified in
> [25.11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.11).
> If `%Z` is used, it will be replaced with `"UTC"` widened to `charT`. If `%z`
> is used (or a modified variant of `%z`), an offset of `0min` will be
> formatted.
> :::

Modify section 25.7.2.3 Non-member functions [[time.clock.utc.nonmembers]](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#subsubsection.25.7.2.3):

> ::: rm
> \pnum{1} *Effects:* Calls `to_stream(os, fmt, t)`, where `fmt` is a string
> containing `"%F %T"` widened to `charT`.
> :::
<!-- Passing locale to format seems unnecessary because %F and %T are
     locale-independent. -->
> ::: add
> \pnum{1} *Effects:* Equivalent to `os << format(fmt, t)`, where `fmt` is a
> string containing `"{:%F %T}"` widened to `charT`.
> :::

```diff
- template<class charT, class traits, class Duration>
-   basic_ostream<charT, traits>&
-     to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const utc_time<Duration>& tp);
+ template<class Duration, class charT>
+   struct formatter<utc_time<Duration>, charT>;
```

> ::: rm
> \pnum{3} *Effects:* Streams `tp` into `os` using the format specified by the
> NTCTS `fmt`. `fmt` encoding follows the rules specified in 25.11. If `%Z`
> is used, it will be replaced with `"UTC"` widened to `charT`. If `%z` is used
> (or a modified variant of `%z`), an offset of `0min` will be formatted. If
> `tp` represents a time during a leap second insertion, and if a seconds field
> is formatted, the integral portion of that format shall be `"60"` widened to
> `charT`.
>
> \pnum{4} *Returns:* `os`.
> :::

> ::: add
> The specialization is enabled and the format string encoding follows the rules
> specified in
> [25.11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.11).
> If `%Z` is used, it will be replaced with `"UTC"` widened to `charT`. If `%z`
> is used (or a modified variant of `%z`), an offset of `0min` will be
> formatted. If `tp` represents a time during a leap second insertion, and if a
> seconds field is formatted, the integral portion of that format shall be
> `"60"` widened to `charT`.
> :::

Modify section 25.7.3.3 Non-member functions [time.clock.tai.nonmembers](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#subsubsection.25.7.3.3):

> ::: rm
> \pnum{1} *Effects:* Calls `to_stream(os, fmt, t)`, where `fmt` is a string
> containing `"%F %T"` widened to `charT`.
> :::
> ::: add
> \pnum{1} *Effects:* Equivalent to `os << format(fmt, t)`, where `fmt` is a
> string containing `"{:%F %T}"` widened to `charT`.
> :::

TODO: replace all `to_stream` overloads with `formatter` specializations and
      rephrase references to `to_stream` in terms of `format`.

Modify section 25.11 Formatting [[time.format]](
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.11):

> ::: rm
> \pnum{1} Each `format` overload specified in this subclause calls `to_stream`
> unqualified, so as to enable argument dependent lookup
> ([6.4.2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#subsection.6.4.2)).
>
> ```
> template<class charT, class Streamable>
>   basic_string<charT>
>     format(const charT* fmt, const Streamable& s);
> ```
>
> ...
>
> \pnum{13} Returns: `os.str()`.
>
> \pnum{14} The `format` functions call a `to_stream` function with a
> `basic_ostream`, a formatting string specifier, and a `Streamable` argument.
> Each `to_stream` overload is customized for each `Streamable` type. However all
> `to_stream` overloads treat the formatting string specifier according to the
> following specification:
>
> \pnum{15} The `fmt` string consists of zero or more conversion specifiers and
> ordinary multibyte characters. A conversion specifier consists of a `%`
> character, possibly followed by an `E` or `O` modifier character (described
> below), followed by a character that determines the behavior of the conversion
> specifier. All ordinary multibyte characters (excluding the terminating null
> character) are streamed unchanged into the `basic_ostream`.
> :::

> ::: add
> Each `formatter` specialization in the chrono library
> ([25.2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#section.25.2))
> satisfies the *Formatter* requirements
> ([[formatter.requirements]](http://fmtlib.net/P0645R4.html#gensection-6)).
>
> The `parse` member functions of these formatters treat the formatting string
> according to the following specification:
>
> ```
> format-spec     ::= [[fill] align] [width] [conversion-spec [chrono-specs]]
> chrono-specs    ::= chrono-spec [chrono-specs]
> chrono-spec     ::= literal-char | conversion-spec
> literal-char    ::= <a character other than '{' or '}'>
> conversion-spec ::= '%' [modifier] type
> modifier        ::= 'E' | 'O'
> type            ::= 'a' | 'A' | 'b' | 'B' | 'c' | 'C' | 'd' | 'D' | 'e' | 'F' | 'g' |
>                     'G' | 'h' | 'H' | 'I' | 'j' | 'm' | 'M' | 'n' | 'p' | 'r' | 'R' |
>                     'S' | 't' | 'T' | 'u' | 'U' | 'V' | 'w' | 'W' | 'x' | 'X' | 'y' |
>                     'Y' | 'z' | 'Z' | '%'
> ```
>
> `fill`, `align`, and `width` are described in Section
> [[format.functions]](http://fmtlib.net/P0645R4.html#format-functions).
> All ordinary multibyte characters represented by `literal-char` are copied
> unchanged to the output.
> :::

> ::: rm
> \pnum{16} Each conversion specifier is replaced by appropriate characters as
> described in Table [88](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf#table.25.88).
> Some of the conversion specifiers depend on the locale which is imbued to the
> `basic_ostream`. If the `Streamable` object does not contain the information
> the conversion specifier refers to, the value streamed to the `basic_ostream`
> is unspecified.
> :::

> ::: add
> Each conversion specifier `conversion-spec` is replaced by appropriate
> characters as described in Table 88. Some of the conversion specifiers depend
> on the locale which is passed to the formatting function if the latter takes
> one or the global locale otherwise. If the formatted object does not contain
> the information the conversion specifier refers to, the value written to the
> output is unspecified.
> :::

> ::: rm
> \pnum{17} Unless explicitly specified, `Streamable` types will not contain
> time zone abbreviation and time zone offset information. If available, the
> conversion specifiers `%Z` and `%z` will format this information
> (respectively). If the information is not available, and `%Z` or `%z` are
> contained in `fmt`, `os.setstate(ios_base::failbit)` shall be called.
> :::

> ::: add
> Unless explicitly specified, formatted chrono types will not contain time zone
> abbreviation and time zone offset information. If available, the conversion
> specifiers `%Z` and `%z` will format this information (respectively). If the
> information is not available, and `%Z` or `%z` are contained in `format-spec`,
> `format_error` shall be thrown.
> :::

> Table 88 -- Meaning of [`format`]{.rm} conversion specifiers

--------------------------------------------------------------------------------
Specifier Replacement
--------- ----------------------------------------------------------------------
`%a`      The locale’s abbreviated weekday name. If the value does not contain a
          valid weekday, [`setstate(ios::failbit)` is called]{.rm}
          [`format_error` is thrown]{.add}.

`%A`      The locale’s full weekday name. If the value does not contain a valid
          weekday, [`setstate(ios::failbit)` is called]{.rm}
          [`format_error` is thrown]{.add}.

`%b`      The locale’s abbreviated month name. If the value does not contain a
          valid month, [`setstate(ios::failbit)` is called]{.rm}
          [`format_error` is thrown]{.add}.

TODO      remaining conversion specifiers
--------------------------------------------------------------------------------

> ::: add
> If the format specification contains no conversion specifiers then the
> chrono object is formatted as if by streaming it to `std::ostringstream` `os`
> and copying `os.str()` through the output iterator of the context with
> additional padding and adjustments as per format specifiers.
> :::

> ::: add
> [_Example:_
> ```
>   string s = format("{:>8}", 42ms); // s == "    42ms"
> ```
> _--- end example_]
> :::

TODO: global or C locale?

## Changes to P0645 Text Formatting

The wording in this section is based on [@P0645].

Modify section 19.20.1 Header `<format>` synopsis
[[format.syn]](http://fmtlib.net/P0645R4.html#gensection-5):

```diff
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);
+ template<class... Args>
+   string format(const locale& loc, string_view fmt, const Args&... args);
+ template<class... Args>
+   wstring format(const locale& loc, wstring_view fmt, const Args&... args);

...

  wstring vformat(wstring_view fmt, wformat_args args);
+ string vformat(const locale& loc, string_view fmt, format_args args);
+ wstring vformat(const locale& loc, wstring_view fmt, wformat_args args);

...

  template<OutputIterator<const wchar_t&> O, class... Args>
    O format_to(O out, wstring_view fmt, const Args&... args);
+ template<OutputIterator<const char&> O, class... Args>
+   O format_to(O out, const locale& loc, string_view fmt, const Args&... args);
+ template<OutputIterator<const wchar_t&> O, class... Args>
+   O format_to(O out, const locale& loc, wstring_view fmt, const Args&... args);

...

  template<OutputIterator<const wchar_t&> O>
    O vformat_to(O out, wstring_view fmt, format_args_t<O, wchar_t> args);
+ template<OutputIterator<const char&> O>
+   O vformat_to(O out, const locale& loc, string_view fmt,
+                format_args_t<O, char> args);
+ template<OutputIterator<const wchar_t&> O>
+   O vformat_to(O out, const locale& loc, wstring_view fmt,
+                format_args_t<O, wchar_t> args);

...

  template<OutputIterator<const char&> O, class... Args>
    format_to_n_result<O> format_to_n(O out, iter_difference_t<O> n,
                                      string_view fmt, const Args&... args);
+ template<OutputIterator<const char&> O, class... Args>
+   format_to_n_result<O> format_to_n(O out, iter_difference_t<O> n,
+                                     const locale& loc, string_view fmt,
+                                     const Args&... args);
+ template<OutputIterator<const wchar_t&> O, class... Args>
+   format_to_n_result<O> format_to_n(O out, iter_difference_t<O> n,
+                                     const locale& loc, wstring_view fmt,
+                                     const Args&... args);

...

  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
+ template<class... Args>
+   size_t formatted_size(const locale& loc, string_view fmt,
+                         const Args&... args);
+ template<class... Args>
+   size_t formatted_size(const locale& loc, wstring_view fmt,
+                         const Args&... args);
```

Modify section 19.20.2 Formatting functions
[[format.functions]](http://fmtlib.net/P0645R4.html#format.functions):

> ::: add
> ```
> template<class... Args>
>   string format(const locale& loc, string_view fmt, const Args&... args);
> ```
> *Returns:* `vformat(loc, fmt, make_format_args(args...))`.
>
> ```
> template<class... Args>
>   wstring format(const locale& loc, wstring_view fmt, const Args&... args);
> ```
> *Returns:* `vformat(loc, fmt, make_wformat_args(args...))`.
>
> ```
> string vformat(const locale& loc, string_view fmt, format_args args);
> ```
> *Returns:* A string object holding the character representation of formatting
> arguments provided by args formatted according to specifications given in
> `fmt` using `loc` for locale-specific formatting.
>
> *Throws:* `format_error` if `fmt` is not a valid format string.
> :::

TODO: remaining functions

Modify section 19.20.3.3 Class template `basic_format_context`
[[format.context]](http://fmtlib.net/P0645R4.html#format.context):

```diff
  template<class O, class charT> requires OutputIterator<O, const charT&>
    class basic_format_context {
    public:
...
      basic_format_arg<basic_format_context> arg(size_t id) const;
+     std::locale locale();
...
    };
```

> ::: add
> ```
> std::locale locale();
> ```
> _Returns_: The locale passed to a formatting function if the latter takes one
> or `std::locale()` otherwise.
> :::

---
references:
  - id: N4727
    citation-label: N4727
    title: Working Draft, Standard for Programming Language C++
    author:
      - family: Smith
        given: [Richard]
    issued:
      year: 2018
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4727.pdf
  - id: P0355
    citation-label: P0355
    title: Extending <chrono> to Calendars and Time Zones
    author:
      - family: Hinnant
        given: [Howard E.]
      - family: Kamiński
        given: [Tomasz]
    issued:
      year: 2018
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0355r7.html
  - id: P0645
    citation-label: P0645
    title: Text Formatting
    author:
      family: Zverovich
      given: [Victor]
    issued:
      year: 2018
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0645r3.html
---
